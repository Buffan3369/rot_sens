ET <- lapply(X = SD_remain, FUN = sd, na.rm = TRUE) #standard deviation (of averaged standard deviations... (yes, it's tricky)
avet <- data.frame(Time = TIMESCALE,
Av = as.numeric(AVERAGE), #we invert to plot it in a proper geological way
std = as.numeric(ET))
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
scale_y_continuous(expand = c(0,0), limits = c(0, 40)) +
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ts_plot
i = 2
frame = FRAMES[[i]]
to_keep <- which((SD$lon_0 %in% seq(from = frame[["lon_w"]], to = frame[["lon_e"]], by = 0.5))
&
(SD$lat_0 %in% seq(from = frame[["lat_s"]], to = frame[["lat_n"]], by = 0.5))) #target the cells in the frame
SD_remain <- SD[to_keep, -c(which(seq(from = 1, to = ncol(SD)+1, by = 1) %%2 != 0))] #only keep latitudes (even col indexes) for the selected cells (row indexes in to_keep)
SD_remain$lat_0 <- 0 #we set to 0 the lat sd at t = 0, which is normal
AVERAGE <- lapply(X = SD_remain, FUN = mean, na.rm = TRUE) #average over space
ET <- lapply(X = SD_remain, FUN = sd, na.rm = TRUE) #standard deviation (of averaged standard deviations... (yes, it's tricky)
avet <- data.frame(Time = TIMESCALE,
Av = as.numeric(AVERAGE), #we invert to plot it in a proper geological way
std = as.numeric(ET))
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
#scale_y_continuous(expand = c(0,0), limits = c(0, 40)) +
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ts_plot
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
scale_y_continuous(expand = c(0,0), limits = c(0, 40)) +
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ts_plot
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
scale_y_continuous(expand = c(0,0), limits = c(-5, 40)) +
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ts_plot
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
scale_y_continuous(expand = c(0,0), limits = c(-8, 40)) +
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ts_plot
for(i in 1:length(FRAMES)){
frame = FRAMES[[i]]
to_keep <- which((SD$lon_0 %in% seq(from = frame[["lon_w"]], to = frame[["lon_e"]], by = 0.5))
&
(SD$lat_0 %in% seq(from = frame[["lat_s"]], to = frame[["lat_n"]], by = 0.5))) #target the cells in the frame
SD_remain <- SD[to_keep, -c(which(seq(from = 1, to = ncol(SD)+1, by = 1) %%2 != 0))] #only keep latitudes (even col indexes) for the selected cells (row indexes in to_keep)
SD_remain$lat_0 <- 0 #we set to 0 the lat sd at t = 0, which is normal
AVERAGE <- lapply(X = SD_remain, FUN = mean, na.rm = TRUE) #average over space
ET <- lapply(X = SD_remain, FUN = sd, na.rm = TRUE) #standard deviation (of averaged standard deviations... (yes, it's tricky)
avet <- data.frame(Time = TIMESCALE,
Av = as.numeric(AVERAGE), #we invert to plot it in a proper geological way
std = as.numeric(ET))
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
scale_y_continuous(expand = c(0,0), limits = c(-8, 40)) +
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ggsave(filename = paste0("./figures/time_series/FRAME_", i, ".pdf" ),
plot = ts_plot,
width = 10,
height = 6)
}
for(i in 1:length(FRAMES)){
frame = FRAMES[[i]]
to_keep <- which((SD$lon_0 %in% seq(from = frame[["lon_w"]], to = frame[["lon_e"]], by = 0.5))
&
(SD$lat_0 %in% seq(from = frame[["lat_s"]], to = frame[["lat_n"]], by = 0.5))) #target the cells in the frame
SD_remain <- SD[to_keep, -c(which(seq(from = 1, to = ncol(SD)+1, by = 1) %%2 != 0))] #only keep latitudes (even col indexes) for the selected cells (row indexes in to_keep)
SD_remain$lat_0 <- 0 #we set to 0 the lat sd at t = 0, which is normal
AVERAGE <- lapply(X = SD_remain, FUN = mean, na.rm = TRUE) #average over space
ET <- lapply(X = SD_remain, FUN = sd, na.rm = TRUE) #standard deviation (of averaged standard deviations... (yes, it's tricky)
avet <- data.frame(Time = TIMESCALE,
Av = as.numeric(AVERAGE), #we invert to plot it in a proper geological way
std = as.numeric(ET))
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
scale_y_continuous(expand = c(0,0), limits = c(-8, 44)) + #although no values <0, he confidence interval can be "theoretically" negative, hence the -8
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ggsave(filename = paste0("./figures/time_series/FRAME_", i, ".pdf" ),
plot = ts_plot,
width = 10,
height = 6)
}
for(i in 1:length(FRAMES)){
frame = FRAMES[[i]]
to_keep <- which((SD$lon_0 %in% seq(from = frame[["lon_w"]], to = frame[["lon_e"]], by = 0.5))
&
(SD$lat_0 %in% seq(from = frame[["lat_s"]], to = frame[["lat_n"]], by = 0.5))) #target the cells in the frame
SD_remain <- SD[to_keep, -c(which(seq(from = 1, to = ncol(SD)+1, by = 1) %%2 != 0))] #only keep latitudes (even col indexes) for the selected cells (row indexes in to_keep)
SD_remain$lat_0 <- 0 #we set to 0 the lat sd at t = 0, which is normal
AVERAGE <- lapply(X = SD_remain, FUN = mean, na.rm = TRUE) #average over space
ET <- lapply(X = SD_remain, FUN = sd, na.rm = TRUE) #standard deviation (of averaged standard deviations... (yes, it's tricky)
avet <- data.frame(Time = TIMESCALE,
Av = as.numeric(AVERAGE), #we invert to plot it in a proper geological way
std = as.numeric(ET))
ts_plot <- ggplot(data = avet, aes(x = Time, y = Av, ymin = Av-std, ymax = Av+std))+
scale_x_reverse(breaks = seq(from = 0, to = 500, by = 100))+
scale_y_continuous(expand = c(0,0), limits = c(-8, 44)) + #although no values <0, he confidence interval can be "theoretically" negative, hence the -8
geom_line(lwd = 2, colour = '#006837')+
geom_smooth(stat = "identity")+ #get the
theme(text = element_text(size = 25),
axis.line = element_line(colour = "black", size = 1, linetype = "solid"),
axis.text.x = element_text(size = 23),
axis.text.y = element_text(size = 23),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1)) + #frame the plot
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1) +
labs(x = "Time (Ma)", y= "Averaged Latitude SD (°)")
ggsave(filename = paste0("./figures/time_series/FRAME_", i, ".pdf" ),
plot = ts_plot,
width = 10,
height = 6)
}
## Import model's polygons as shapefiles and proceed to the georeferencing ----------------------------
source("./scripts/data_analysis/georeferencing_and_NA_pos.R") #georeferencing
source("./scripts/data_analysis/cells_to_drop.R") #spatial scaling of the ourputs of the models
## import our friend ggplot ------------------------------------------------------------------
library(ggplot2)
## Read sd results and get rid of longitude (odd indexes) ------------------------------------
sds <- readRDS("./data/standard_deviation_4mdls_nothresh.RDS")
sds <- sds[-MAX, -c(1:2, which(seq(from = 3, to = ncol(sds)+1, by = 1) %%2 != 0))] #MAX comes from the "cell_to_drop.R" script
final_df <- data.frame(TIME = rep(x = 0, 5),
CAT = c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°"),
COUNTS = c(29500, 0, 0, 0, 0))
for(t in seq(from = 10, to = 540, by = 10)){
final_df <- rbind(final_df,
data.frame(TIME = rep(x = t, 5),
CAT = c("A: 0-5°", "B: 5-10°", "C: 10-20°", "D: 20-30°", "E: >30°"),  #the five categories we're considering
COUNTS = c(
length(which(sds[, t/10] < 5)),
length(which((sds[, t/10] < 10) & (sds[, t/10] >= 5))), #translating these categories in terms of logical condition
length(which((sds[, t/10] < 20) & (sds[, t/10] >= 10))),
length(which((sds[, t/10] < 30) & (sds[, t/10] >= 20))),
length(which(sds[, t/10] >= 30))
)
))
}
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_manual(values = c('#FFB380', '#FF7F2A', 'FF6600', 'D45500', 'AA4400')) +
# scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_manual(values = c('#FFB380', '#FF7F2A', '#FF6600', '#D45500', '#AA4400')) +
# scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_manual(values = c('#fff7bc','#fec44f','#ec7014','#993404','#662506')) +
# scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_manual(values = c('#fff7bc','#fec44f','#fe9929','#ec7014','#662506')) +
# scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_manual(values = c('#fee391','#fec44f','#fe9929','#ec7014','#662506')) +
# scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed") +
geom_vline(xintercept = 410, col = "red", linetype = "dashed")
print(barplt)
#raw counts
barplt <- ggplot(data = final_df, aes(fill = CAT, x = TIME, y = COUNTS)) +
geom_bar(position = "stack", #display counts
stat = "identity") +
scale_fill_manual(values = c('#fee391','#fec44f','#fe9929','#ec7014','#662506')) +
# scale_fill_viridis(discrete = T) +
scale_x_reverse() +
theme(axis.title.x = element_text(size = 18),
axis.title.y = element_text(size = 18),
axis.text = element_text(size = 15),
legend.title = element_text(size = 18),
legend.text = element_text(size = 15),
legend.key.size = unit(1, "cm"),
panel.grid.major = element_blank(), # Remove panel grid lines
panel.grid.minor = element_blank(),
panel.background = element_blank(), # Remove panel background
panel.border = element_rect(colour = "black", fill = NA, size = 1) #frame the plot
) +
labs(x = "Time (Ma)", y = "Counts", fill = "Category") +
geom_vline(xintercept = 200, col = "red", linetype = "dashed", lwd = 1) +
geom_vline(xintercept = 410, col = "red", linetype = "dashed", lwd = 1)
print(barplt)
## set the background map -------------------------------------------------------------
source("./scripts/visualisation/background_map.R") #nb: ignore warnings
## Plot and save latitude standard deviation time series ------------------------------
source("./scripts/visualisation/plot_lat_sd.R") #idem
## Plot and save barplots -------------------------------------------------------------
source("./scripts/visualisation/barplots.R")
pal <- c('#fee391','#fec44f','#fe9929','#ec7014','#cc4c02','#993404','#662506') #set the palette
df <- readRDS("./data/standard_deviation_4mdls.RDS")
for(k in seq(from = 4, to = ncol(df), by = 2)){ #we start with the latitude of the -10My point (4th column)
true_time <- (k-2)*5 #for the plot title ( = ((k-2)/2)*10 )
xyz <- df[, c(1,2,k)] #select the corresponding latitude deviation
r <- rasterFromXYZ(xyz,
crs = "+proj=longlat +datum=WGS84")  #write the raster file with the UTM projection coord sys
proj_moll <- "+proj=moll +lon_0=0 +x_0=0 +y_0=0"  #mollweide projection
p <- projectRaster(r, crs = proj_moll)
if(true_time < 100){  #add a zero in front of true_time in the name of the file so that the program used to compile the plot as a GIF could sort them properely
png(paste0("./figures/standard_deviation/", 0, true_time, ".png"))
}
else{
png(paste0("./figures/standard_deviation/", true_time, ".png"))
}
plot.new()
#
# rect(par("usr")[1], par("usr")[3],
#      par("usr")[2], par("usr")[4],
#      col = "grey92") #set light grey background
# par(new = TRUE)
par(bg = "grey92")
plot(p,
axes = FALSE,
col = pal,
main = paste0("Latitude Standard Deviation between the models ", "(", true_time ,"Ma)"),
legend.args = list(text = 'Standard deviation', side = 4, font = 2, line = 2.5, cex = 0.8),
zlim = c(0, 60))  #display the output
plot(worldline_mol,
add = TRUE,
col = adjustcolor("grey30",alpha.f=0.5)) #add background map with a semi-transparent grey colour
dev.off()
}
## set the background map -------------------------------------------------------------
source("./scripts/visualisation/background_map.R") #nb: ignore warnings
## Plot and save latitude standard deviation time series ------------------------------
source("./scripts/visualisation/plot_lat_sd.R") #idem
## Plot and save barplots -------------------------------------------------------------
source("./scripts/visualisation/barplots.R")
# Author: Lewis A. Jones
# Copyright (c) Lewis A. Jones, 2022
# Email: LewisA.Jones@outlook.com
#
# Script name:
# data_prep.R
# Script description:
# Data preparation and cleaning of Crocodylomorpha occurrence data set
#---------------------------------------------------------------------
#load libraries needed for script
library(dplyr)
library(tibble)
#---------------------------------------------------------------------
#Download all Crocodylomorpha occurrences from the Paleobiology Database (https://paleobiodb.org/#/) using the API service
data <- read.csv("https://paleobiodb.org/data1.2/occs/list.csv?base_name=Crocodylomorpha&show=class")
#save raw data
saveRDS(data, "./data/occurrences/raw_croc_dataset.RDS")
#Analyses focused on terrestrial taxa, load text file and remove all marine taxa from database
marine_taxa <- read.delim("./data/occurrences/marine_taxa.txt", header = FALSE)[,1]
View(data)
?filter
#filter data from PBDB classification
data <- data %>% filter(!family %in% marine_taxa) #filter subsets dataframe according to the condition indicated
data <- data %>% filter(!genus %in% marine_taxa)
data <- data %>% filter(!accepted_name %in% marine_taxa)
#remove all form and ichnotaxa occurrence data
data <- data %>% filter(!flags %in% c("IF", "F", "I"))
#add mid_ma col
data <- data %>% add_column(mid_ma = (data$max_ma+data$min_ma)/2, .before = "min_ma")
#create empty columns for populating
data$bin_mid_ma <- NA
#whole of Phanerozoic
lower <- seq(from = 540, to = 10, by = -10)
mid <- seq(from = 535, to = 5, by = -10)
upper <- seq(from = 530, to = 0, by = -10)
#assign bins to data
for(i in 1:length(upper)){
data[which(data$mid_ma < lower[i] & data$mid_ma > upper[i]),c("bin_mid_ma")] <- mid[i]
}
#---------------------------------------------------------------------
#Download all Crocodylomorpha occurrences from the Paleobiology Database (https://paleobiodb.org/#/) using the API service
data <- read.csv("https://paleobiodb.org/data1.2/occs/list.csv?base_name=Crocodylomorpha&show=class&lngmin=-90&lngmax=90&latmin=-180&latmax=180")
View(data)
library(devtools)
install_github("ropensci/paleobioDB")
library(paleobioDB)
#---------------------------------------------------------------------
#Download all Crocodylomorpha occurrences from the Paleobiology Database (https://paleobiodb.org/#/) using the API service
data <- read.csv("https://paleobiodb.org/data1.2/occs/list.csv?base_name=Crocodylomorpha&show=class&lngmin=-90&lngmax=90&latmin=-180&latmax=180")
#save raw data
saveRDS(data, "./data/occurrences/raw_croc_dataset.RDS")
#Analyses focused on terrestrial taxa, load text file and remove all marine taxa from database
marine_taxa <- read.delim("./data/occurrences/marine_taxa.txt", header = FALSE)[,1]
#filter data from PBDB classification
data <- data %>% filter(!family %in% marine_taxa) #filter subsets dataframe according to the condition indicated
data <- data %>% filter(!genus %in% marine_taxa)
data <- data %>% filter(!accepted_name %in% marine_taxa)
#remove all form and ichnotaxa occurrence data
data <- data %>% filter(!flags %in% c("IF", "F", "I"))
#add mid_ma col
data <- data %>% add_column(mid_ma = (data$max_ma+data$min_ma)/2, .before = "min_ma")
#create empty columns for populating
data$bin_mid_ma <- NA
#whole of Phanerozoic
lower <- seq(from = 540, to = 10, by = -10)
mid <- seq(from = 535, to = 5, by = -10)
upper <- seq(from = 530, to = 0, by = -10)
#assign bins to data
for(i in 1:length(upper)){
data[which(data$mid_ma < lower[i] & data$mid_ma > upper[i]),c("bin_mid_ma")] <- mid[i]
}
plot_map(data)
pbdb_map(data)
data <- pbdb_occurrences(base_name="Crocodylomorpha", show = c("class"))
data <- pbdb_occurrences(base_name="Crocodylomorpha", vocab = "pbdb", show = c("class"))
#---------------------------------------------------------------------
#Download all Crocodylomorpha occurrences from the Paleobiology Database (https://paleobiodb.org/#/) using the API service
data <- read.csv("https://paleobiodb.org/data1.2/occs/list.csv?base_name=Crocodylomorpha&show=class&show=loc&lngmin=-90&lngmax=90&latmin=-180&latmax=180")
#---------------------------------------------------------------------
#Download all Crocodylomorpha occurrences from the Paleobiology Database (https://paleobiodb.org/#/) using the API service
data <- read.csv("https://paleobiodb.org/data1.2/occs/list.csv?base_name=Crocodylomorpha&show=class&show=coords&lngmin=-90&lngmax=90&latmin=-180&latmax=180")
View(data)
#save raw data
saveRDS(data, "./data/occurrences/raw_croc_dataset.RDS")
#Analyses focused on terrestrial taxa, load text file and remove all marine taxa from database
marine_taxa <- read.delim("./data/occurrences/marine_taxa.txt", header = FALSE)[,1]
#filter data from PBDB classification
data <- data %>% filter(!family %in% marine_taxa) #filter subsets dataframe according to the condition indicated
data <- data %>% filter(!genus %in% marine_taxa)
data <- data %>% filter(!accepted_name %in% marine_taxa)
#remove all form and ichnotaxa occurrence data
data <- data %>% filter(!flags %in% c("IF", "F", "I"))
#add mid_ma col
data <- data %>% add_column(mid_ma = (data$max_ma+data$min_ma)/2, .before = "min_ma")
#create empty columns for populating
data$bin_mid_ma <- NA
#whole of Phanerozoic
lower <- seq(from = 540, to = 10, by = -10)
mid <- seq(from = 535, to = 5, by = -10)
upper <- seq(from = 530, to = 0, by = -10)
#assign bins to data
for(i in 1:length(upper)){
data[which(data$mid_ma < lower[i] & data$mid_ma > upper[i]),c("bin_mid_ma")] <- mid[i]
}
#assign bins to data
for(i in 1:length(upper)){
data[which(data$mid_ma < lower[i] & data$mid_ma > upper[i]),c("bin_mid_ma")] <- mid[i]
data[which(data$mid_ma < lower[i] & data$mid_ma > upper[i]),c("bin_max_ma")] <- lower[i]
}
#SAVE DATA--------------------------------------------------------------
saveRDS(data, "./data/occurrences/cleaned_croc_dataset.RDS")
