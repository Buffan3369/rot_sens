E = runif(10, min = 0, max = 10),
FF = runif(10, min = 0, max = 10),
G = runif(10, min = 0, max = 10),
H = runif(10, min = 0, max = 10))
NAMES <- c("gol", "set", "sco", "mat")
L <- list()
df$MST <- 0
for(i in 1:nrow(df)){
L[["gol"]] <- c(df[i, 1], df[i, 2])
L[["set"]] <- c(df[i, 3], df[i, 4])
L[["sco"]] <- c(df[i, 5], df[i, 6])
L[["mat"]] <- c(df[i, 7], df[i, 8])
#we get the distance matrix
Dissim <- matrix(0, nrow = 4, ncol = 4, dimnames = list(NAMES, NAMES)) #initialise dist matrix
NAMES_copy <- NAMES
k = 1
while(k < length(NAMES)){
name1 <- NAMES[[k]]
for(name2 in NAMES_copy){
if(name2 != name1){
line <- rbind(L[[name1]], L[[name2]])
len <- lengthLine(line)/1000 #convert in km
Dissim[k, which(NAMES == name2)] <- len
}
}
NAMES_copy <- NAMES_copy[-c(1)]
k = k+1
}
sorting <- sort(Dissim) #we sort its values in increasing order
sort_no_0 <- sorting[-c(which(sorting == 0))] #exclude zeros
MST_length <- sum(sort_no_0[1:3]) #select the 3 smallest values and sum them: we have our MST length (greedy algorithm)
df$MST[i] <- MST_length
}
View(df)
length(Timescale)
#This script georeferences the coordinates of the grid with the spatial polygons of each rotation model
#This would enable us to attribute a plateID to each point.
#In the case of the models that only consider continental plates motion, the points in the oceans will just be attributed to no plateID
## Loading libraries ---------------------------------------------------------------------------------------------------
library(raster)
## BUILD THE GRID AGAIN ------------------------------------------------------------------------------------------------
r <- raster(res = 1) #start with a 1x1 raster
pos <- xyFromCell(object = r, cell = 1:ncell(r))  #extract coordinates as a df
xy <- data.frame(pos)
xy$Beginning <- 500 #500Ma ago, beginning of rotation
xy$End <- 0
xy.df <- SpatialPointsDataFrame(coords = xy[,1:2], data = xy)
proj4string(xy.df)<- CRS("+proj=longlat +datum=WGS84") #assign coord system to the SpatialPointsDataFrame
## Function to import models' polygons as shapefiles and proceed to the georeferencing ------------------------------------
get_na_pos <- function(mdl){
#returns indexes of the pixels associated with non attributed plateIDs (plateID = NA)
#In the terrestrial-only models, these points are the ocean plates. However, as not all model have the same plate boundaries, there might be discrepancies between the models
#As plates are dynamic features in the Seton model, we didn't carried out the georeferencing on it
if(mdl != "Seton"){
dir <- paste0("./data/continental_polygons/",
mdl, "/",
mdl, "_PresentDay_ContinentalPolygons.shp")
shape <- shapefile(dir) #we open the corresponding Gplates shapefile
georef <- over(xy.df, shape)$PLATEID1  #georeferencing the spatial data points with the Gplates shp
merged <- cbind.data.frame(xy.df, georef)  #merging both
#   NO NEED TO RUN THE LINE BELOW IF IT'S NOT THE FIRST TIME
saveRDS(merged, file = paste0("./data/georeferenced/", mdl,".RDS"))  #get df with the assigned plate IDs
indexes <- which(is.na(georef) == TRUE)
}
else { #plateIDs assignment complicated for Seton, so we just remove it from this part of the work
indexes <- c()
}
return(indexes)
}
############ THIS SCRIPT ASSESSES THE INDEXES OF THE CELLS TO DROP FOR THE SPATIAL SCALING ###################
## Loading libraries -----------------------------------------------------------------------------------------
library(sp)
library(abind)
## List of model's names -------------------------------------------------------------------------------------
models <- c("Scotese2",  #PALEOMAP latest version
"Matthews",
"Golonka",
"Seton")
## Computing the List of the indexes to drop to spatially scale the outputs ----------------------------------
i = 1
MAX <- get_na_pos(models[i]) # function in "georeferencing_and_NA_pos.R" script
while(i<4){
i = i+1
test <- get_na_pos(models[i])
if(length(test) > length(MAX)){
MAX <- test
print(models[i]) #GOLONKA IS THE MODEL WITH THE SMALLER NUMBER OF CELLS WITH VALUES
}
} #length(MAX) = 34651
#we look for potential remaining NAs in the other models after removing all cells not covered by Golonka
to_add <- c() #list that will contain the indexes to add, ie remaining NAs in the Matthew and Scotese datasets after cleaning golonka's NAs position
for(mdl in c("Scotese2", "Matthews")){
georef <- readRDS(paste0("./data/georeferenced/", mdl,".RDS"))
to_add <- c(to_add, which(is.na(georef$georef[-MAX]) == TRUE)) #we add the remaining NAs after cleaning up Golonka's ones
}
MAX <- c(MAX, unique(to_add)) #these NAs are added and we use unique() to avoid adding twice the same indexes
#length(MAX) = 35911 => we work with 64800-length(MAX) = 28889 cells
GOLONKA <- readRDS('./data/extracted_paleocoordinates/Golonka.RDS')[-MAX,] #we directly get rid of the elements that are not further treated, to lower computing time
SETON <- readRDS('./data/extracted_paleocoordinates/Seton.RDS')[-MAX,]
MATTHEWS <- readRDS('./data/extracted_paleocoordinates/Matthews.RDS')[-MAX,]
SCOTESE <- readRDS('./data/extracted_paleocoordinates/Scotese2.RDS')[-MAX,]
#final matrix that will contain the MST length over time
MST_mat <- matrix(0,
nrow = 64800 - length(MAX),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
MST_df <- data.frame(MST_mat)
MST_df[, 1:2] <- GOLONKA[, 1:2] #coordinates
cnames <- c("lon_0", "lat_0")
for(t in Timescale){
cnames <- c(cnames, paste0("MST_length_", t))
}
colnames(MST_df) <- cnames
View(MST_df)
#final matrix that will contain the MST length over time
MST_mat <- matrix(0,
nrow = 64800 - length(MAX),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
MST_df <- data.frame(MST_mat)
MST_df[, 1:2] <- GOLONKA[, 1:2] #coordinates
cnames <- c("lon_0", "lat_0")
NAMES <- c("gol", "set", "sco", "mat")
L <- list()
for(t in Timescale){
cnames <- c(cnames, paste0("MST_length_", t))
for(i in 1:nrow(df)){
L[["gol"]] <- c(GOLONKA[i, 2*t/10+1], GOLONKA[i, 2*t/10+2])
L[["set"]] <- c(SETON[i, 2*t/10+1], SETON[i, 2*t/10+2])
L[["sco"]] <- c(SCOTESE[i, 2*t/10+1], SCOTESE[i, 2*t/10+2])
L[["mat"]] <- c(MATTHEWS[i, 2*t/10+1], MATTHEWS[i, 2*t/10+2])
#we get the distance matrix
Dissim <- matrix(0, nrow = 4, ncol = 4, dimnames = list(NAMES, NAMES)) #initialise dist matrix
NAMES_copy <- NAMES
k = 1
while(k < length(NAMES)){
name1 <- NAMES[[k]]
for(name2 in NAMES_copy){
if(name2 != name1){
line <- rbind(L[[name1]], L[[name2]])
len <- lengthLine(line)/1000 #convert in km
Dissim[k, which(NAMES == name2)] <- len
}
}
NAMES_copy <- NAMES_copy[-c(1)]
k = k+1
}
sorting <- sort(Dissim) #we sort its values in increasing order
sort_no_0 <- sorting[-c(which(sorting == 0))] #exclude zeros
MST_length <- sum(sort_no_0[1:3]) #select the 3 smallest values and sum them: we have our MST length (greedy algorithm)
MST_df[i, t/10+2] <- MST_length
}
}
colnames(MST_df) <- cnames
View(MST_df)
NAMES <- c("gol", "set", "sco", "mat")
L <- list()
for(t in Timescale){
cnames <- c(cnames, paste0("MST_length_", t))
for(i in 1:nrow(MST_df)){
L[["gol"]] <- c(GOLONKA[i, 2*t/10+1], GOLONKA[i, 2*t/10+2])
L[["set"]] <- c(SETON[i, 2*t/10+1], SETON[i, 2*t/10+2])
L[["sco"]] <- c(SCOTESE[i, 2*t/10+1], SCOTESE[i, 2*t/10+2])
L[["mat"]] <- c(MATTHEWS[i, 2*t/10+1], MATTHEWS[i, 2*t/10+2])
#we get the distance matrix
Dissim <- matrix(0, nrow = 4, ncol = 4, dimnames = list(NAMES, NAMES)) #initialise dist matrix
NAMES_copy <- NAMES
k = 1
while(k < length(NAMES)){
name1 <- NAMES[[k]]
for(name2 in NAMES_copy){
if(name2 != name1){
line <- rbind(L[[name1]], L[[name2]])
len <- lengthLine(line)/1000 #convert in km
Dissim[k, which(NAMES == name2)] <- len
}
}
NAMES_copy <- NAMES_copy[-c(1)]
k = k+1
}
sorting <- sort(Dissim) #we sort its values in increasing order
sort_no_0 <- sorting[-c(which(sorting == 0))] #exclude zeros
MST_length <- sum(sort_no_0[1:3]) #select the 3 smallest values and sum them: we have our MST length (greedy algorithm)
MST_df[i, t/10+2] <- MST_length
}
}
View(MST_df)
for(t in seq(from = 120, to = 200, by = 10)){
for(i in 1:nrow(MST_df)){
L[["gol"]] <- c(GOLONKA[i, 2*t/10+1], GOLONKA[i, 2*t/10+2])
L[["set"]] <- c(SETON[i, 2*t/10+1], SETON[i, 2*t/10+2])
L[["sco"]] <- c(SCOTESE[i, 2*t/10+1], SCOTESE[i, 2*t/10+2])
L[["mat"]] <- c(MATTHEWS[i, 2*t/10+1], MATTHEWS[i, 2*t/10+2])
#we get the distance matrix
Dissim <- matrix(0, nrow = 4, ncol = 4, dimnames = list(NAMES, NAMES)) #initialise dist matrix
NAMES_copy <- NAMES
k = 1
while(k < length(NAMES)){
name1 <- NAMES[[k]]
for(name2 in NAMES_copy){
if(name2 != name1){
line <- rbind(L[[name1]], L[[name2]])
len <- lengthLine(line)/1000 #convert in km
Dissim[k, which(NAMES == name2)] <- len
}
}
NAMES_copy <- NAMES_copy[-c(1)]
k = k+1
}
sorting <- sort(Dissim) #we sort its values in increasing order
sort_no_0 <- sorting[-c(which(sorting == 0))] #exclude zeros
MST_length <- sum(sort_no_0[1:3]) #select the 3 smallest values and sum them: we have our MST length (greedy algorithm)
MST_df[i, t/10+2] <- MST_length
}
}
for(t in T){
cnames <- c(cnames, paste0("MST_length_", t))
}
colnames(MST_df) <- cnames
cnames <- c("lon_0", "lat_0")
for(t in T){
cnames <- c(cnames, paste0("MST_length_", t))
}
colnames(MST_df) <- cnames
saveRDS(MST_df, "./data/MST_length_loaf.RDS")
?distm
?lapply
MST_mat <- matrix(0,
nrow = 64800 - length(MAX),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
MST_df <- data.frame(MST_mat)
MST_df[, 1:2] <- GOLONKA[, 1:2] #coordinates
SCOTESE <- readRDS('./data/extracted_paleocoordinates/Scotese2.RDS')
length(unique(MAX))
nrow(SCOTESE[-MAX,])
64800-length(unique(MAX))
64800-length(MAX)
#This script georeferences the coordinates of the grid with the spatial polygons of each rotation model
#This would enable us to attribute a plateID to each point.
#In the case of the models that only consider continental plates motion, the points in the oceans will just be attributed to no plateID
## Loading libraries ---------------------------------------------------------------------------------------------------
library(raster)
## BUILD THE GRID AGAIN ------------------------------------------------------------------------------------------------
r <- raster(res = 1) #start with a 1x1 raster
pos <- xyFromCell(object = r, cell = 1:ncell(r))  #extract coordinates as a df
xy <- data.frame(pos)
xy$Beginning <- 500 #500Ma ago, beginning of rotation
xy$End <- 0
xy.df <- SpatialPointsDataFrame(coords = xy[,1:2], data = xy)
proj4string(xy.df)<- CRS("+proj=longlat +datum=WGS84") #assign coord system to the SpatialPointsDataFrame
## Function to import models' polygons as shapefiles and proceed to the georeferencing ------------------------------------
get_na_pos <- function(mdl){
#returns indexes of the pixels associated with non attributed plateIDs (plateID = NA)
#In the terrestrial-only models, these points are the ocean plates. However, as not all model have the same plate boundaries, there might be discrepancies between the models
#As plates are dynamic features in the Seton model, we didn't carried out the georeferencing on it
if(mdl != "Seton"){
dir <- paste0("./data/continental_polygons/",
mdl, "/",
mdl, "_PresentDay_ContinentalPolygons.shp")
shape <- shapefile(dir) #we open the corresponding Gplates shapefile
georef <- over(xy.df, shape)$PLATEID1  #georeferencing the spatial data points with the Gplates shp
merged <- cbind.data.frame(xy.df, georef)  #merging both
#   NO NEED TO RUN THE LINE BELOW IF IT'S NOT THE FIRST TIME
saveRDS(merged, file = paste0("./data/georeferenced/", mdl,".RDS"))  #get df with the assigned plate IDs
indexes <- which(is.na(georef) == TRUE)
}
else { #plateIDs assignment complicated for Seton, so we just remove it from this part of the work
indexes <- c()
}
return(indexes)
}
############ THIS SCRIPT ASSESSES THE INDEXES OF THE CELLS TO DROP FOR THE SPATIAL SCALING ###################
## Loading libraries -----------------------------------------------------------------------------------------
library(sp)
library(abind)
## List of model's names -------------------------------------------------------------------------------------
models <- c("Scotese2",  #PALEOMAP latest version
"Matthews",
"Golonka",
"Seton")
## Computing the List of the indexes to drop to spatially scale the outputs ----------------------------------
i = 1
MAX <- get_na_pos(models[i]) # function in "georeferencing_and_NA_pos.R" script
while(i<4){
i = i+1
test <- get_na_pos(models[i])
if(length(test) > length(MAX)){
MAX <- test
print(models[i]) #GOLONKA IS THE MODEL WITH THE SMALLER NUMBER OF CELLS WITH VALUES
}
} #length(MAX) = 34651
MAX <- unique(MAX)
#we look for potential remaining NAs in the other models after removing all cells not covered by Golonka
to_add <- c() #list that will contain the indexes to add, ie remaining NAs in the Matthew and Scotese datasets after cleaning golonka's NAs position
for(mdl in c("Scotese2", "Matthews")){
georef <- readRDS(paste0("./data/georeferenced/", mdl,".RDS"))
to_add <- c(to_add, which(is.na(georef$georef[-MAX]) == TRUE)) #we add the remaining NAs after cleaning up Golonka's ones
}
MAX <- c(MAX, unique(to_add)) #these NAs are added and we use unique() to avoid adding twice the same indexes
#length(MAX) = 35911 => we work with 64800-length(MAX) = 28889 cells
SCOTESE <- readRDS('./data/extracted_paleocoordinates/Scotese2.RDS')[-MAX]
MST_mat <- matrix(0,
nrow = 64800 - length(MAX),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
library(geosphere)
Timescale <- seq(from = 10, to = 200, by = 10) #The timescale of the study will the upper bound of the model going shallower in time: SETON, 200Ma
GOLONKA <- readRDS('./data/extracted_paleocoordinates/Golonka.RDS')[-MAX,] #we directly get rid of the elements that are not further treated, to lower computing time
SETON <- readRDS('./data/extracted_paleocoordinates/Seton.RDS')[-MAX,]
MATTHEWS <- readRDS('./data/extracted_paleocoordinates/Matthews.RDS')[-MAX,]
SCOTESE <- readRDS('./data/extracted_paleocoordinates/Scotese2.RDS')[-MAX]
library(vegan)
MST_mat <- matrix(0,
nrow = 64800 - length(MAX),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
MST_df <- data.frame(MST_mat)
#This script georeferences the coordinates of the grid with the spatial polygons of each rotation model
#This would enable us to attribute a plateID to each point.
#In the case of the models that only consider continental plates motion, the points in the oceans will just be attributed to no plateID
## Loading libraries ---------------------------------------------------------------------------------------------------
library(raster)
## BUILD THE GRID AGAIN ------------------------------------------------------------------------------------------------
r <- raster(res = 1) #start with a 1x1 raster
pos <- xyFromCell(object = r, cell = 1:ncell(r))  #extract coordinates as a df
xy <- data.frame(pos)
xy$Beginning <- 500 #500Ma ago, beginning of rotation
xy$End <- 0
xy.df <- SpatialPointsDataFrame(coords = xy[,1:2], data = xy)
proj4string(xy.df)<- CRS("+proj=longlat +datum=WGS84") #assign coord system to the SpatialPointsDataFrame
## Function to import models' polygons as shapefiles and proceed to the georeferencing ------------------------------------
get_na_pos <- function(mdl){
#returns indexes of the pixels associated with non attributed plateIDs (plateID = NA)
#In the terrestrial-only models, these points are the ocean plates. However, as not all model have the same plate boundaries, there might be discrepancies between the models
#As plates are dynamic features in the Seton model, we didn't carried out the georeferencing on it
if(mdl != "Seton"){
dir <- paste0("./data/continental_polygons/",
mdl, "/",
mdl, "_PresentDay_ContinentalPolygons.shp")
shape <- shapefile(dir) #we open the corresponding Gplates shapefile
georef <- over(xy.df, shape)$PLATEID1  #georeferencing the spatial data points with the Gplates shp
merged <- cbind.data.frame(xy.df, georef)  #merging both
#   NO NEED TO RUN THE LINE BELOW IF IT'S NOT THE FIRST TIME
saveRDS(merged, file = paste0("./data/georeferenced/", mdl,".RDS"))  #get df with the assigned plate IDs
indexes <- which(is.na(georef) == TRUE)
}
else { #plateIDs assignment complicated for Seton, so we just remove it from this part of the work
indexes <- c()
}
return(indexes)
}
############ THIS SCRIPT ASSESSES THE INDEXES OF THE CELLS TO DROP FOR THE SPATIAL SCALING ###################
## Loading libraries -----------------------------------------------------------------------------------------
library(sp)
library(abind)
## List of model's names -------------------------------------------------------------------------------------
models <- c("Scotese2",  #PALEOMAP latest version
"Matthews",
"Golonka",
"Seton")
## Computing the List of the indexes to drop to spatially scale the outputs ----------------------------------
i = 1
MAX <- get_na_pos(models[i]) # function in "georeferencing_and_NA_pos.R" script
while(i<4){
i = i+1
test <- get_na_pos(models[i])
if(length(test) > length(MAX)){
MAX <- test
print(models[i]) #GOLONKA IS THE MODEL WITH THE SMALLER NUMBER OF CELLS WITH VALUES
}
}
MAX <- unique(MAX)
#we look for potential remaining NAs in the other models after removing all cells not covered by Golonka
to_add <- c() #list that will contain the indexes to add, ie remaining NAs in the Matthew and Scotese datasets after cleaning golonka's NAs position
for(mdl in c("Scotese2", "Matthews")){
georef <- readRDS(paste0("./data/georeferenced/", mdl,".RDS"))
to_add <- c(to_add, which(is.na(georef$georef[-MAX]) == TRUE)) #we add the remaining NAs after cleaning up Golonka's ones
}
MAX <- c(MAX, unique(to_add)) #these NAs are added and we use unique() to avoid adding twice the same indexes
#length(MAX) = 35300 => we work with 64800-length(MAX) = 29500 cells
MST_mat <- matrix(0,
nrow = 64800 - length(unique(MAX)),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
MST_df <- data.frame(MST_mat)
MST_df[, 1:2] <- GOLONKA[, 1:2] #coordinates
t = 10
dist_mats <- lapply(rbind(cbind(GOLONKA[, 2*t/10+1], GOLONKA[, 2*t/10+2]),
cbind(SETON[, 2*t/10+1], SETON[, 2*t/10+2]),
cbind(SCOTESE[, 2*t/10+1], SCOTESE[, 2*t/10+2]),
cbind(MATTHEWS[, 2*t/10+1], MATTHEWS[, 2*t/10+2])),
FUN = distm)
dist_mats <- lapply(rbind(cbind(GOLONKA[, 3], GOLONKA[, 4]),
cbind(SETON[, 3], SETON[, 4]),
cbind(SCOTESE[, 3], SCOTESE[, 4]),
cbind(MATTHEWS[, 3], MATTHEWS[, 4])),
FUN = distm)
SCOTESE <- readRDS('./data/extracted_paleocoordinates/Scotese2.RDS')[-MAX,]
dist_mats <- lapply(rbind(cbind(GOLONKA[, 3], GOLONKA[, 4]),
cbind(SETON[, 3], SETON[, 4]),
cbind(SCOTESE[, 3], SCOTESE[, 4]),
cbind(MATTHEWS[, 3], MATTHEWS[, 4])),
FUN = distm)
df1 <- data.frame(A = runif(10, min = 0, max = 10),
B = runif(10, min = 0, max = 10))
df2 <- data.frame(A = runif(10, min = 0, max = 10),
B = runif(10, min = 0, max = 10))
df3 <- data.frame(A = runif(10, min = 0, max = 10),
B = runif(10, min = 0, max = 10))
df4 <- data.frame(A = runif(10, min = 0, max = 10),
B = runif(10, min = 0, max = 10))
df1 <- data.frame(A = runif(2, min = 0, max = 10),
B = runif(2, min = 0, max = 10))
df2 <- data.frame(A = runif(2, min = 0, max = 10),
B = runif(2, min = 0, max = 10))
df3 <- data.frame(A = runif(2, min = 0, max = 10),
B = runif(2, min = 0, max = 10))
df4 <- data.frame(A = runif(2, min = 0, max = 10),
B = runif(2, min = 0, max = 10))
test = rbind(cbind(df1[, 3], df1[, 4]),
cbind(df2[, 3], df2[, 4]),
cbind(df3[, 3], df3[, 4]),
cbind(df4[, 3], df4[, 4]))
test = rbind(cbind(df1[, 1], df1[, 2]),
cbind(df2[, 1], df2[, 2]),
cbind(df3[, 1], df3[, 2]),
cbind(df4[, 1], df4[, 2]))
test
df1
mat <- lapply(test, FUN = distm)
mat <- sapply(test, FUN = distm)
mat <- tapply(test, FUN = distm)
mat <- apply(test, FUN = distm)
i = 2
dist_mats <- lapply(rbind(cbind(GOLONKA[i, 3], GOLONKA[i, 4]),
cbind(SETON[i, 3], SETON[i, 4]),
cbind(SCOTESE[i, 3], SCOTESE[i, 4]),
cbind(MATTHEWS[i, 3], MATTHEWS[i, 4])),
FUN = distm)
rbind(cbind(GOLONKA[i, 3], GOLONKA[i, 4]),
cbind(SETON[i, 3], SETON[i, 4]),
cbind(SCOTESE[i, 3], SCOTESE[i, 4]),
cbind(MATTHEWS[i, 3], MATTHEWS[i, 4]))
dist_mat <- distm(rbind(cbind(GOLONKA[i, 3], GOLONKA[i, 4]),
cbind(SETON[i, 3], SETON[i, 4]),
cbind(SCOTESE[i, 3], SCOTESE[i, 4]),
cbind(MATTHEWS[i, 3], MATTHEWS[i, 4])),
fun = distGeo)
MST <- length(spantree(dist_mat))
MST_mat <- matrix(0,
nrow = 64800 - length(unique(MAX)),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
MST_df <- data.frame(MST_mat)
MST_df[, 1:2] <- GOLONKA[, 1:2] #coordinates
cnames <- c("lon_0", "lat_0")
for(t in Timescale){
cnames <- c(cnames, paste0("MST_length_", t))
for(i in 1:nrow(MST_df)){
dist_mat <- distm(rbind(cbind(GOLONKA[i, 2*t/10+1], GOLONKA[i, 2*t/10+2]),
cbind(SETON[i, 2*t/10+1], SETON[i, 2*t/10+2]),
cbind(SCOTESE[i, 2*t/10+1], SCOTESE[i, 2*t/10+2]),
cbind(MATTHEWS[i, 2*t/10+1], MATTHEWS[i, 2*t/10+2])),
fun = distGeo)
MST_df[i, t/10+2] = length(spantree(dist_mat))
}
}
saveRDS(MST_df, "./data/MST_length.RDS")
View(MST_df)
t = 10
i = 2
dist_mat <- distm(rbind(cbind(GOLONKA[i, 3], GOLONKA[i, 4]),
cbind(SETON[i, 3], SETON[i, 4]),
cbind(SCOTESE[i, 3], SCOTESE[i, 4]),
cbind(MATTHEWS[i, 3], MATTHEWS[i, 4])),
fun = distGeo)
MST <- length(spantree(dist_mat))
MST
rbind(cbind(GOLONKA[i, 3], GOLONKA[i, 4]),
cbind(SETON[i, 3], SETON[i, 4]),
cbind(SCOTESE[i, 3], SCOTESE[i, 4]),
cbind(MATTHEWS[i, 3], MATTHEWS[i, 4]))
distm(x = rbind(c(-20.8202, 83.77718), c(-43.29776, 83.23735), c(-44.29776, 84.37459), c(-52.5000, 84.5)))
D = distm(x = rbind(c(-20.8202, 83.77718), c(-43.29776, 83.23735), c(-44.29776, 84.37459), c(-52.5000, 84.5)))
length(spantree(D))
spantree(D)
plot(spantree(d = D))
?spantree
sum(spantree(D)$dist)/1000
dist_mat
MST_mat <- matrix(0,
nrow = 64800 - length(unique(MAX)),
ncol = length(Timescale)+2 #as many wows as we have time intervals + 2 supplementary for the coordinates
)
MST_df <- data.frame(MST_mat)
MST_df[, 1:2] <- GOLONKA[, 1:2] #coordinates
cnames <- c("lon_0", "lat_0")
for(t in Timescale){
cnames <- c(cnames, paste0("MST_length_", t))
for(i in 1:nrow(MST_df)){
dist_mat <- distm(rbind(cbind(GOLONKA[i, 2*t/10+1], GOLONKA[i, 2*t/10+2]),
cbind(SETON[i, 2*t/10+1], SETON[i, 2*t/10+2]),
cbind(SCOTESE[i, 2*t/10+1], SCOTESE[i, 2*t/10+2]),
cbind(MATTHEWS[i, 2*t/10+1], MATTHEWS[i, 2*t/10+2])),
fun = distGeo)
MST_df[i, t/10+2] = sum(spantree(dist_mat)$dist)/1000 #in km
}
}
colnames(MST_df) <- cnames
saveRDS(MST_df, "./data/MST_length.RDS")
View(MST_df)
